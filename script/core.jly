
(define print
  (lambda [x]
    (display (object->string x))))

(define prn
  (lambda [x]
    (print x)
    (newline)))

(define null?
  (lambda [x]
    (identical? x ())))

(define cadr
  (lambda [lst]
    (car (cdr lst))))

(define append
  (lambda [lst1 lst2]
    (if (null? lst1)
      lst2
      (cons (car lst1) (append (cdr lst1) lst2)))))

(define cons*
  (lambda xs
    (define x (car xs))
    (define y (cdr xs))
    (if y
      (cons x (apply cons* y))
      x)))

(define map
  (lambda [f lst]
    (if lst
      (cons (f (car lst)) (map f (cdr lst)))
      '())))

(define-syntax lambda_
  (lambda forms
    (set! forms (cdr forms))
    (define args (car forms))
    (define body (cdr forms))
    (cons*
      'lambda args
      @('define '&form @('car args))
      @('set! args @('cdr args))
      body)))

(define-syntax let
  (lambda_ forms
    (define bindings (car forms))
    (define body (cdr forms))
    (define names (map car bindings))
    (define expressions (map cadr bindings))
    (cons (cons* 'lambda names body) expressions)))

(define build-let*
  (lambda [bindings body]
    (if bindings
      (let ([binding (car bindings)])
        @('let @(binding) (build-let* (cdr bindings) body)))
      (cons 'begin body))))

(define-syntax let*
  (lambda_ forms
    (let ([bindings (car forms)]
          [body (cdr forms)])
      (build-let* bindings body))))

(define-syntax or
  (lambda_ forms
    (let ([x (car forms)]
          [xs (cdr forms)]
          [tmp (gensym "or")])
      (if xs
        @('let @(@[tmp x])
          @('if tmp tmp (cons 'or xs)))
        x))))

(define-syntax when
  (lambda_ forms
    (let ([condition (car forms)]
          [body (cdr forms)])
      @('if condition (cons* 'let [] body) ()))))

(define for-each
  (lambda [f lst]
    (when lst
      (f (car lst))
      (for-each f (cdr lst)))))

(define zero?
  (lambda [x]
    (= x 0)))
